import { useState, useCallback, useRef, useEffect } from 'react';
import { getApiUrl } from '../lib/config';

// Storage keys for thread persistence
const STORAGE_KEY_THREAD_ID = 'weft_ai_chat_thread_id';
const STORAGE_KEY_AGENT_ID = 'weft_ai_chat_agent_id';

export interface ContextItem {
  type: 'journal' | 'note';
  id: string;
  title: string;
  content?: string;
  date?: string;
}

export interface ToolCall {
  toolCallId: string;
  toolName: string;
  status: 'calling' | 'executing' | 'completed' | 'error';
  args?: Record<string, unknown>;
  result?: unknown;
  error?: string;
}

export interface ThinkingBlock {
  content: string;
  isComplete: boolean;
}

export interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
  thinking?: string;
  thinkingBlocks?: ThinkingBlock[];
  isThinking?: boolean;
  isStreaming?: boolean;
  toolCalls?: ToolCall[];
  timestamp: Date;
}

/**
 * Check if a message is an Ollama workaround synthetic message
 * These are generated by the server to feed tool results back to the model
 * and should not be displayed to the user.
 */
function isOllamaWorkaroundMessage(content: string): boolean {
  // The workaround message format starts with this specific text
  return content.startsWith('The following tool calls were executed and returned these results:');
}

/**
 * Convert Mastra message format to ChatMessage format
 */
function convertMastraMessagesToChat(mastraMessages: MastraMessage[]): ChatMessage[] {
  return mastraMessages.map(msg => {
    let content = '';
    let thinking = '';
    const toolCalls: ToolCall[] = [];

    if (msg.content != null) {
      if (typeof msg.content === 'string') {
        content = msg.content;
      } else if (Array.isArray(msg.content)) {
        // Handle array content (AI SDK v1 format)
        for (const part of msg.content) {
          if (part.type === 'text' && part.text) {
            content += part.text;
          } else if (part.type === 'tool-call') {
            toolCalls.push({
              toolCallId: part.toolCallId || '',
              toolName: part.toolName || '',
              status: 'completed',
              args: part.args,
            });
          }
        }
      } else if (typeof msg.content === 'object') {
        // Handle AI SDK v2 format: { format: 2, parts: [...], toolInvocations: [...] }
        const contentObj = msg.content as Record<string, unknown>;

        if (contentObj.format === 2 && Array.isArray(contentObj.parts)) {
          // AI SDK v2 format
          for (const part of contentObj.parts as MastraContentPart[]) {
            if (part.type === 'text' && part.text) {
              content += part.text;
            } else if (part.type === 'reasoning') {
              // Extract reasoning/thinking content
              const reasoningText = part.reasoning ||
                part.details?.map(d => d.text).filter(Boolean).join('') || '';
              thinking += reasoningText;
            } else if (part.type === 'tool-invocation' && part.toolInvocation) {
              const invocation = part.toolInvocation;
              toolCalls.push({
                toolCallId: invocation.toolCallId,
                toolName: invocation.toolName,
                status: invocation.state === 'result' ? 'completed' : 'calling',
                args: invocation.args,
                result: invocation.result,
              });
            }
          }
        } else {
          // Fallback: try to extract text from common fields
          content = String(contentObj.text || contentObj.content || '');
        }
      }
    }

    return {
      role: msg.role as 'user' | 'assistant',
      content,
      ...(thinking && { thinking }),
      ...(toolCalls.length > 0 && { toolCalls }),
      timestamp: new Date(msg.createdAt || Date.now()),
    };
  }).filter(msg => {
    // Filter out Ollama workaround messages (synthetic tool result messages)
    if (msg.role === 'user' && isOllamaWorkaroundMessage(msg.content)) {
      return false;
    }
    // Keep messages with content, user messages, or tool calls
    return msg.content || msg.role === 'user' || msg.toolCalls?.length;
  });
}

/**
 * Mastra message format from API
 */
interface MastraMessage {
  id: string;
  role: string;
  content: string | MastraContentPart[] | MastraContentV2 | Record<string, unknown>;
  createdAt?: string;
}

/**
 * AI SDK v2 content format from Mastra memory
 */
interface MastraContentV2 {
  format: 2;
  parts: MastraContentPart[];
  toolInvocations?: ToolInvocation[];
}

/**
 * Content part in AI SDK format
 */
interface MastraContentPart {
  type: 'text' | 'reasoning' | 'tool-invocation' | 'tool-call' | 'tool-result';
  text?: string;
  reasoning?: string;
  details?: Array<{ type: string; text?: string }>;
  toolInvocation?: ToolInvocation;
  toolCallId?: string;
  toolName?: string;
  args?: Record<string, unknown>;
}

/**
 * Tool invocation in AI SDK v2 format
 */
interface ToolInvocation {
  state: 'calling' | 'partial' | 'result';
  toolCallId: string;
  toolName: string;
  args?: Record<string, unknown>;
  result?: unknown;
}

/**
 * Parse thinking content from text that may contain thinking tags
 */
function parseThinkingFromText(text: string): { thinking: string; content: string; isThinking: boolean } {
  const patterns = [
    { regex: /<think\b[^>]*>([\s\S]*?)<\/think>/gi, hasEnd: true },
    { regex: /<think\/>([\s\S]*?)<\/think\/>/gi, hasEnd: true },
  ];

  for (const { regex } of patterns) {
    const matches = [...text.matchAll(new RegExp(regex.source, regex.flags))];

    if (matches.length > 0) {
      const thinkingParts: string[] = [];
      let content = text;

      for (const match of matches) {
        thinkingParts.push(match[1].trim());
        content = content.replace(match[0], '');
      }

      return {
        thinking: thinkingParts.join('\n\n'),
        content: content.trim(),
        isThinking: false,
      };
    }
  }

  const openTagMatch = text.match(/<think\b[^>]*>([^]*?)$/i);
  if (openTagMatch) {
    const thinkingContent = openTagMatch[1];
    const contentBefore = text.slice(0, openTagMatch.index);
    return {
      thinking: thinkingContent,
      content: contentBefore.trim(),
      isThinking: true,
    };
  }

  return {
    thinking: '',
    content: text,
    isThinking: false,
  };
}

interface UseAIChatOptions {
  conversationId?: string;
  agentId?: 'journalAgent' | 'assistantAgent';
}

interface UseAIChatReturn {
  messages: ChatMessage[];
  isLoading: boolean;
  isInitializing: boolean;
  error: string | null;
  conversationId: string;
  sendMessage: (message: string, context?: ContextItem[]) => Promise<void>;
  clearConversation: () => void;
}

export function useAIChat(options: UseAIChatOptions = {}): UseAIChatReturn {
  const { conversationId: initialConversationId, agentId = 'assistantAgent' } = options;

  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isInitializing, setIsInitializing] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [conversationId, setConversationId] = useState(() => {
    // Initialize from localStorage if agent matches
    const storedAgentId = localStorage.getItem(STORAGE_KEY_AGENT_ID);
    const storedThreadId = localStorage.getItem(STORAGE_KEY_THREAD_ID);

    if (storedAgentId === agentId && storedThreadId) {
      return storedThreadId;
    }

    // Agent changed or no stored thread, generate new ID
    return initialConversationId || `conv-${Date.now()}`;
  });

  const abortControllerRef = useRef<AbortController | null>(null);

  // Load existing thread messages on mount
  useEffect(() => {
    async function loadThread() {
      const storedAgentId = localStorage.getItem(STORAGE_KEY_AGENT_ID);
      const storedThreadId = localStorage.getItem(STORAGE_KEY_THREAD_ID);

      // Only load if agent matches and we have a stored thread ID
      if (storedAgentId === agentId && storedThreadId) {
        try {
          const response = await fetch(`${getApiUrl()}/api/mastra/threads/${storedThreadId}/messages`, {
            credentials: 'include',
          });

          if (response.ok) {
            const data = await response.json();
            console.log('[AI Chat] Loaded thread data:', data);
            if (data.messages && data.messages.length > 0) {
              console.log('[AI Chat] Raw message sample:', data.messages[0]);
              const convertedMessages = convertMastraMessagesToChat(data.messages);
              console.log('[AI Chat] Converted messages:', convertedMessages);
              setMessages(convertedMessages);
            }
            // Update conversation ID to the stored one
            setConversationId(storedThreadId);
          } else {
            // Thread not found or not accessible, clear localStorage
            console.log('[AI Chat] Thread not found, clearing storage');
            localStorage.removeItem(STORAGE_KEY_THREAD_ID);
            setConversationId(`conv-${Date.now()}`);
          }
        } catch (err) {
          // Network error or other issue, just start fresh
          console.warn('[AI Chat] Failed to load thread messages:', err);
          localStorage.removeItem(STORAGE_KEY_THREAD_ID);
          setConversationId(`conv-${Date.now()}`);
        }
      }

      // Store the current agent ID
      localStorage.setItem(STORAGE_KEY_AGENT_ID, agentId);
      setIsInitializing(false);
    }

    loadThread();
  }, [agentId]);

  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  const sendMessage = useCallback(async (
    message: string,
    context: ContextItem[] = []
  ) => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    setIsLoading(true);
    setError(null);

    // Track if this is a new chat (before adding the user message)
    const isNewChat = messages.length === 0;

    const userMessage: ChatMessage = {
      role: 'user',
      content: message,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);

    // Track state outside React
    let hasStructuredReasoning = false;
    const thinkingBlocks: ThinkingBlock[] = [];
    const toolCallsMap = new Map<string, ToolCall>();
    let rawContent = '';

    // Create placeholder message
    const assistantMessageId = Date.now();
    setMessages(prev => [...prev, {
      role: 'assistant',
      content: '',
      thinking: '',
      thinkingBlocks: [],
      isThinking: false,
      isStreaming: true,
      toolCalls: [],
      timestamp: new Date(assistantMessageId),
    }]);

    // Helper to update message with current state
    const updateMessage = () => {
      setMessages(prev => {
        const newMessages = [...prev];
        const lastMessage = newMessages[newMessages.length - 1];

        if (lastMessage?.role === 'assistant') {
          // Process thinking from raw content if no structured reasoning
          if (!hasStructuredReasoning) {
            const parsed = parseThinkingFromText(rawContent);
            lastMessage.content = parsed.content;
            lastMessage.thinking = parsed.thinking;
            lastMessage.isThinking = parsed.isThinking;
          } else {
            lastMessage.content = rawContent;
          }
        }

        return newMessages;
      });
    };

    try {
      const response = await fetch(`${getApiUrl()}/api/mastra/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          message,
          conversationId,
          agentId,
          context: { selectedItems: context },
          isNewChat,
        }),
        signal: abortController.signal,
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to send message: ${response.statusText}`);
      }

      const responseConversationId = response.headers.get('X-Conversation-ID');
      if (responseConversationId) {
        setConversationId(responseConversationId);
        // Persist thread ID to localStorage for session recovery
        localStorage.setItem(STORAGE_KEY_THREAD_ID, responseConversationId);
        localStorage.setItem(STORAGE_KEY_AGENT_ID, agentId);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('No response body');
      }

      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          updateMessage();
          break;
        }

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (!line.trim()) continue;

          try {
            const chunk = JSON.parse(line);

            setMessages(prev => {
              const newMessages = [...prev];
              const lastMessage = newMessages[newMessages.length - 1];

              if (lastMessage?.role === 'assistant') {
                switch (chunk.type) {
                  case 'reasoning-start':
                    hasStructuredReasoning = true;
                    lastMessage.isThinking = true;
                    thinkingBlocks.push({ content: '', isComplete: false });
                    lastMessage.thinkingBlocks = [...thinkingBlocks];
                    break;

                  case 'reasoning-delta':
                    if (thinkingBlocks.length > 0) {
                      thinkingBlocks[thinkingBlocks.length - 1].content += chunk.payload?.text || '';
                      lastMessage.thinkingBlocks = [...thinkingBlocks];
                      lastMessage.thinking = thinkingBlocks.map(b => b.content).join('\n\n---\n\n');
                    }
                    break;

                  case 'reasoning-end':
                    lastMessage.isThinking = false;
                    if (thinkingBlocks.length > 0) {
                      thinkingBlocks[thinkingBlocks.length - 1].isComplete = true;
                      lastMessage.thinkingBlocks = [...thinkingBlocks];
                    }
                    break;

                  case 'text-delta': {
                    // Simply accumulate text - component handles animation
                    const text = chunk.payload?.text || '';
                    rawContent += text;
                    lastMessage.content = rawContent;
                    break;
                  }

                  case 'tool-call':
                  case 'tool-call-input-streaming-start': {
                    const toolCallId = chunk.payload?.toolCallId;
                    const toolName = chunk.payload?.toolName;
                    if (toolCallId && toolName) {
                      const toolCall: ToolCall = {
                        toolCallId,
                        toolName,
                        status: 'calling',
                        args: chunk.payload?.args,
                      };
                      toolCallsMap.set(toolCallId, toolCall);
                      lastMessage.toolCalls = Array.from(toolCallsMap.values());
                    }
                    break;
                  }

                  case 'tool-call-delta': {
                    const toolCallId = chunk.payload?.toolCallId;
                    if (toolCallId) {
                      const existing = toolCallsMap.get(toolCallId);
                      if (existing) {
                        existing.status = 'executing';
                        lastMessage.toolCalls = Array.from(toolCallsMap.values());
                      }
                    }
                    break;
                  }

                  case 'tool-result': {
                    const toolCallId = chunk.payload?.toolCallId;
                    if (toolCallId) {
                      const existing = toolCallsMap.get(toolCallId);
                      if (existing) {
                        existing.status = 'completed';
                        existing.result = chunk.payload?.result;
                        lastMessage.toolCalls = Array.from(toolCallsMap.values());
                      }
                    }
                    break;
                  }

                  case 'tool-error': {
                    const toolCallId = chunk.payload?.toolCallId;
                    if (toolCallId) {
                      const existing = toolCallsMap.get(toolCallId);
                      if (existing) {
                        existing.status = 'error';
                        existing.error = chunk.payload?.error?.message || chunk.payload?.error || 'Tool execution failed';
                        lastMessage.toolCalls = Array.from(toolCallsMap.values());
                      }
                    }
                    break;
                  }

                  case 'error':
                    lastMessage.content = `Error: ${chunk.payload?.error || 'Unknown error'}`;
                    lastMessage.isStreaming = false;
                    break;

                  case 'finish':
                    // Content is already updated in text-delta
                    break;
                }
              }

              return newMessages;
            });
          } catch {
            // If JSON parsing fails, treat as plain text
            const text = line;
            rawContent += text;
            updateMessage();
          }
        }
      }

      // Mark streaming as complete
      setMessages(prev => {
        const newMsgs = [...prev];
        const last = newMsgs[newMsgs.length - 1];
        if (last?.role === 'assistant') {
          last.isStreaming = false;
          last.isThinking = false;
        }
        return newMsgs;
      });

    } catch (err) {
      if (err instanceof Error && err.name === 'AbortError') {
        return;
      }

      const errorMessage = err instanceof Error ? err.message : 'Failed to send message';
      setError(errorMessage);

      setMessages(prev => {
        const filtered = prev.filter((msg, idx) =>
          !(idx === prev.length - 1 && msg.role === 'assistant' && msg.content === '')
        );
        return [...filtered, {
          role: 'assistant',
          content: `Sorry, I encountered an error: ${errorMessage}`,
          timestamp: new Date(),
        }];
      });
    } finally {
      setIsLoading(false);
      abortControllerRef.current = null;
    }
  }, [conversationId, agentId]);

  const clearConversation = useCallback(() => {
    setMessages([]);
    setError(null);
    // Clear localStorage thread ID
    localStorage.removeItem(STORAGE_KEY_THREAD_ID);
    setConversationId(`conv-${Date.now()}`);
  }, []);

  return {
    messages,
    isLoading,
    isInitializing,
    error,
    conversationId,
    sendMessage,
    clearConversation,
  };
}
